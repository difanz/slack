#!/usr/bin/perl -w
# vim:sw=2
# vim600:fdm=marker
# This script is in charge of copying files from the local cache to the root
# of the local filesystem

# This version of the script has to do a lame and racy thing with tar to
# preserve directory permissions.  rsync < 2.6.0 lacks the functionality
# required to copy only files without invoking it multiple times (it has no
# --files-from option).  We can't use tar, unfortuntately, because it does
# not do atomic replacement.

require 5.006;
use warnings FATAL => qw(all);
use strict;

use File::Path;
use File::Find;

use constant DEFAULT_CONFIG_FILE => '/etc/slack.conf';

my @rsync = ('rsync', '-rlptgoDS');

(my $PROG = $0) =~ s#.*/##;

sub save_dir_perms ($);
sub install_files ($);
sub restore_dir_perms ($);

########################################
# Environment
# Helpful prefix to die messages
$SIG{__DIE__} = sub { die "FATAL[$PROG]: @_"; };
# Set a reasonable umask
umask 077;
# Get out of wherever (possibly NFS-mounted) we were
chdir("/")
  or die "Could not chdir /: $!";
# Autoflush on STDERR
select((select(STDERR), $|=1)[0]);

########################################
# Config and option parsing {{{
my $usage = <<EOF;
Usage: $PROG [options] <role> [<role>...]

Options:
  -h, -?, --help
      Print this help message and exit.

  -v, --verbose
      Be verbose

  -C, --config  FILE
      Use this config file instead of /etc/slack.conf

  -s, --source  DIR
      Source for slack files

  -c, --cache  DIR
      Local cache directory for slack files

  -r, --root  DIR
      Root destination for slack files

  -n, --dry-run
      Don't write any files to disk -- just report what would have been done.

  -b, --backups  DIR
      Make backups of existing files and put them in this directory.
EOF

# Option defaults
my %opt = (
  config => DEFAULT_CONFIG_FILE,
  verbose => 0,
);
# A special option to shut off verbose
$opt{quiet} = sub { $opt{verbose} = 0; };

# Reads through the config file
sub read_config () {
  my $config = $opt{config};
  open(CONFIG, "<", $config)
    or die "Could not open config file: $!";
  while(<CONFIG>) {
    chomp;
    s/#.*//; # delete comments
    s/\s+$//; # delete trailing spaces
    next if m/^$/; # skip empty lines
    if (m/^[A-Z_]+=\S+/) {
      my ($key, $value) = split(/=/, $_, 2);
      $key =~ tr/A-Z_/a-z-/;
      if (not defined $opt{$key}) {
        ($opt{verbose} > 2) and print STDERR "Setting '$key' to '$value'\n";
        $opt{$key} = $value;
      }
    } else {
      warn "WARNING[$PROG]: Garbage line '$_' in '$config' line $.\n";
    }
  }
  close(CONFIG)
    or die "Could not close config file: $!";
}

# Collect options
{
    use Getopt::Long;
    Getopt::Long::Configure ("bundling");
    GetOptions(\%opt,
      'verbose|v+',
      'quiet',
      'help|h|?',
      'backups|b=s',
      'config|C=s',
      'dry-run|n',
      'source|s=s',
      'cache|c=s',
      'root|r=s',
      ) or die $usage;
    if ($opt{help}) {
        print $usage;
        exit 0;
    }
    read_config;
}
# }}}

# Arguments are required
die "No roles given!\n\n$usage" unless @ARGV;
die "No root defined!\n\n$usage" unless $opt{root};
die "No cache defined!\n\n$usage" unless $opt{cache};

unless (-d $opt{root}) {
    mkpath($opt{root})
          or die "Could not mkpath destination directory '".
              $opt{root}."': $!\n";
    warn "WARNING[$PROG]: Created destination directory '".$opt{root}."'\n";
}

# Prepare for backups
if ($opt{b}) {
  # Make sure backup directory exists
  unless (-d $opt{b}) {
    $opt{verbose} and print STDERR "Creating backup directory '$opt{b}'\n";
    mkpath($opt{b})
      or die "Could not mkpath backup dir '$opt{b}': $!\n";
  }
  push(@rsync, "--backup", "--backup-dir=$opt{b}");
}
# Pass options along to rsync
if ($opt{'dry-run'}) {
  push @rsync, '--dry-run';
}
if ($opt{verbose}) {
  push @rsync, '--verbose';
}

# copy over the new files
for my $full_role (@ARGV) {
  # Split the full role (e.g. google.foogle.woogle) into components
  my @role = split(/\./, $full_role);
  # with older versions of rsync, there's no good way to copy just
  # files, 
  save_dir_perms($role[0]);
  install_files($role[0]);
  restore_dir_perms($role[0]);
}

# save the directory permissions on local filesystem, to work around missing
# features in older rsync (< 2.6.0).  This is racy.  We will fix this by
# providing an rsync >= 2.6.0 RPM and making a dependency in future versions.
sub save_dir_perms ($) {
  my ($role) = @_;
  my ($tarfile) = $opt{cache} . "/roles/" . $role . "/dirs.tar";
  $opt{verbose} and print STDERR "Saving directories to $tarfile before rsync\n";
  # First, we need to build a list of directories in the files directory
  # since they are the ones that may end up overwriting the local directories
  my $source = $opt{cache} . "/roles/" . $role . "/files";
  my @dirs_to_save = ();
  find ({
      wanted => sub {
        if (-d) {
          my $dir = $File::Find::name;
          $dir =~ s#^$source/##;  # change $opt{cache}/foo => foo
          $dir =~ s#^$source$#.#;  # special case: we want $opt{cache} => .
          push @dirs_to_save, $dir if $dir;
        }
      }
    },
    $source,
  );

  # Next, we tar up all those directories if they exist under /
  # as a cheap way to save the permissions
  my (@command) = qw(tar --create --no-recursion --files-from=-);
  $opt{verbose} and push(@command, "--verbose");
  my ($tarpid, $tarfh);
  if ($tarpid = open($tarfh, '|-')) {
    # Parent
    # (fall through to later)
  } elsif (defined $tarpid) {
    # child
    # open output file
    open(STDOUT, ">", $tarfile)
      or die "Could not open '$tarfile' for writing: $!";

    chdir($opt{root})
      or die "Could not chdir to '".$opt{root}."' before tar: $!";

    exec(@command);
  } else {
    # Error
    die "Could not fork: $!\n";
  }
    
  for my $dir (@dirs_to_save) {
    if (-d $opt{root}."/".$dir) {
      print $tarfh $dir, "\n";
    }
  }
  unless (close ($tarfh)) {
    if ($!) {
        die "Syserr on system '@command': $!\n";
    }
    if ($? & 128) {
        die "'@command' dumped core\n";
    }
    if (my $sig = $? & 127) {
        die "'@command' caught sig $sig\n";
    }
    if (my $exit = $? >> 8) {
        die "'@command' returned $exit\n";
    }
    die "Unknown error on '@command'\n";
  }

}

# save the directory permissions on local filesystem, to work around missing
# features in older rsync (< 2.6.0).  This is racy.  We will fix this by
# providing an rsync >= 2.6.0 RPM and making a dependency in future versions.
sub restore_dir_perms ($) {
  my ($role) = @_;
  my ($tarfile) = $opt{cache} . "/roles/" . $role . "/dirs.tar";
  $opt{verbose} and print STDERR "Restoring directories from $tarfile after rsync\n";
  # Untar the directories from our tar file
  my (@command) = (
    'tar',
    '--directory='.$opt{root},
    '--extract',
    '--preserve-permissions',
    "--file=$tarfile",
  );

  $opt{verbose} and push(@command, "--verbose");
  unless (system(@command) == 0) {
    if ($!) {
        die "Syserr on system '@command': $!\n";
    }
    if ($? & 128) {
        die "'@command' dumped core\n";
    }
    if (my $sig = $? & 127) {
        die "'@command' caught sig $sig\n";
    }
    if (my $exit = $? >> 8) {
        die "'@command' returned $exit\n";
    }
  }
}

sub install_files ($) {
  my ($role) = @_;
  # final / is important for rsync
  my $source = $opt{cache} . "/roles/" . $role . "/files/";
  my $destination = $opt{root} . "/";
  $opt{verbose} and print STDERR "Syncing '$source' to '$destination'\n";
  my @command = (@rsync, $source, $destination);
  unless (system(@command) == 0) {
    if ($!) {
        die "Syserr on system '@command': $!\n";
    }
    if ($? & 128) {
        die "'@command' dumped core\n";
    }
    if (my $sig = $? & 127) {
        die "'@command' caught sig $sig\n";
    }
    if (my $exit = $? >> 8) {
        die "'@command' returned $exit\n";
    }
  }
}

